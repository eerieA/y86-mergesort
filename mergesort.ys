# V2.0
# Calling conventions:
#     %rdi, %rsi, %rdx, %rcx, %r8, %r9, %r10, %r11 and %rax are caller saved
#     %rbx, %rbp, %r12, %r13, %r14 are callee saved
#     %rsp can not be used except for its normal use as a stack pointer.
#     argument are passed through registers %rdi, %rsi, %rdx in this order.
#     values are returned through %rax

.pos 0x100

main:
	irmovq bottom,  %rsp     # initialize stack
	irmovq array, %rdi       # %rdi = pointer to first element of the array
	xorq   %rax, %rax        # %rsi = size
	mrmovq size(%rax), %rsi
	irmovq $1, %rax          # %rsi = size - 1
	subq   %rax, %rsi
	addq   %rsi, %rsi        # %rsi = 8 * (size - 1)
	addq   %rsi, %rsi
	addq   %rsi, %rsi
	addq   %rdi, %rsi        # %rsi = pointer to last element of the array.
	call   mergesort
	halt

#
# Mergesort
#    %rdi: pointer to the first element of the range to sort.
#    %rsi: pointer to the last element of the range to sort.
#
mergesort:
	rrmovq %rsi, %rax  	    # is first < last ?
	subq   %rdi, %rax
	jle    done             # if not, done.

	rrmovq %rdi, %rdx       # %rdx = mid. Note the use  of ANDQ.
	addq   %rsi, %rdx       # Since we're doing arithmetic  with
	irmovq $2,   %rax       # pointers, we can not rely only  on
	divq   %rax, %rdx       # integer division to ensure  we get
	irmovq $-8,  %rax       # a valid pointer.
	andq   %rax, %rdx       

	pushq  %rdi
	pushq  %rsi             
	pushq  %rdx             
	rrmovq %rdx, %rsi       # mergesort(first, mid)
	call   mergesort
	popq   %rdx
	popq   %rsi
	popq   %rdi
    
	pushq  %rdi             # mergesort(mid+1, last)
	pushq  %rsi             
	pushq  %rdx 
	rrmovq %rdx, %rdi
	irmovq $8, %rax
	addq   %rax, %rdi
	call   mergesort
	popq   %rdx
	popq   %rsi
	popq   %rdi

	call   merge            # merge(first, mid, last)

done:	ret

#
# Merge (equivalent to `merge(first, mid, last)`)
#    %rdi: pointer to the first element of the range to merge.
#    %rsi: pointer to the last element of the range to merge.
#    %rdx: pointer to the middle element of the range to merge.
#
# %rdi is i (starts from initial `first`)
# %rcx is j (starts from `last`)
# %rdx is mid
# %rsi is last
# %rbp is dest
merge:
    pushq  %rbp                    # Save initial dest
    pushq  %rbx                    # Save initial ???, by calling convention
    pushq  %rdi                    # Save initial first pointer
    
    irmovq $8,   %r8               # Constant 8 for pointer arithmetic
    irmovq temp, %rbp              # Load temp array address early
    
    # Initialize second pointer (j)
    rrmovq %rdx, %rcx              # mid -> rcx
    addq   %r8, %rcx               # second = mid + 1
    
    # Pre-load values for first comparison
    mrmovq 0(%rdi), %r9            # Pre-load A[i]
    mrmovq 0(%rcx), %r10           # Pre-load A[j]
    
    # Initial bounds check (optimize common case)
    rrmovq %rdx, %rax    
    subq   %rdi, %rax              # mid(%rdx) - first(%rdi)? Mostly >= 0
    jl     prepare_mergeloop2      # Rarely < 0, forward not taken is good
    
    rrmovq %rsi, %rax
    subq   %rcx, %rax              # last(%rsi) - second(%rcx)? Mostly >= 0
    jl     prepare_mergeloop2      # Rarely < 0, forward not taken is good

main_merge_loop:                   # Main loop at the top, backward branch
    # Compare pre-loaded values
    rrmovq %r9, %rax               
    rrmovq %r10, %rbx              
    subq   %rbx, %rax              # A[i] - A[j]? ~ 50-50%
    jge    store_second            # If A[i] >= A[j], store A[j] (smaller)
    
store_first:                       # Store A[i] (smaller)
    rmmovq %r9, 0(%rbp)            
    addq   %r8, %rbp
    addq   %r8, %rdi
    mrmovq 0(%rdi), %r9            # Pre-load next A[i]
    mrmovq 0(%rcx), %r10           # Keep the same A[j]
    
    # Check i bounds inline
    rrmovq %rdx, %rax    
    subq   %rdi, %rax              # mid(%rdx) - first(%rdi)? Mostly >= 0
    jl     prepare_mergeloop2      # Rarely < 0
    jmp    main_merge_loop         # Go on copying first sub array

store_second:                      # Store A[j] (smaller)
    rmmovq %r10, 0(%rbp)           
    addq   %r8, %rbp
    addq   %r8, %rcx
    mrmovq 0(%rdi), %r9            # Keep the same A[i]
    mrmovq 0(%rcx), %r10           # Pre-load next A[j]
    
    # Check j bounds inline
    rrmovq %rsi, %rax
    subq   %rcx, %rax              # last(%rsi) - second(%rcx)? Mostly >= 0
    jl     prepare_mergeloop2      # Rarely < 0
    jmp    main_merge_loop         # Go on copying second sub array

prepare_mergeloop2:
    # Save registers before handling leftovers
    pushq  %rdx                    # Save mid
    pushq  %rsi                    # Save last

    # Handle leftovers from first half
    rrmovq %rdx, %rsi              # Setup args for copy: mid -> last pointer
    rrmovq %rbp, %rdx              # temp -> dest pointer
    call   copy
    rrmovq %rax, %rbp              # Save new temp pointer

    # Handle leftovers from second half
    rrmovq %rcx, %rdi              # second -> first pointer
    popq   %rsi                    # Restore last pointer
    pushq  %rsi                    # Save it again for later
    call   copy
    rrmovq %rax, %rbp              # Save final temp pointer
    
    # Copy everything back to original array
    popq   %rsi                    # Restore last pointer
    popq   %rdx                    # Restore mid pointer
    popq   %rdi                    # Restore initial first pointer
    
    # Setup final copy
    pushq  %rdi                    # Save initial `first` again
    pushq  %rsi                    # Save `last`
    subq   %rdi, %rsi              # %rsi = `last` - initial `first`
    rrmovq %rdi, %rdx              # Original array as destination
    irmovq temp, %rdi              # `temp` points to the first ele for copy()
    addq   %rdi, %rsi              # `temp` + `last` - initial `first` has the last ele for copy()
    
    call   copy
    
    # Cleanup and return
    popq   %rsi                    # Restore `last`
    popq   %rdi                    # Restore initial `first`
    popq   %rbx                    # Restore initial ???, by calling convention
    popq   %rbp                    # Restore initial `dest`
    ret

#
# Copy helper.
#    %rdi [input]: pointer to the first element to copy.
#    %rsi [input]: pointer to the last element to copy.
#    %rdx [input & output]: pointer to where the elements go.
#	
copy:
    irmovq $8, %r8        # Pre-load constant 8 into tmp reg
    
    rrmovq %rsi, %rax     # Prepare for cmp first and last pointers
    subq   %rdi, %rax     # Sets condition codes for the jump
    jl     copyend        # Taken if first > last (default is fwd not taken)
    
copycontinue:
    mrmovq (%rdi), %rax   # Load value from source before updating pointers
    
    addq   %r8, %rdi      # Update pointers while load is happening
    addq   %r8, %rdx      # Can execute while load is pending
    
    # Compare pointers and loop
    rrmovq %rsi, %rbx     # Setup next iteration comparison
    rmmovq %rax, -8(%rdx) # Store loaded value to dest (Reduce stall)
    subq   %rdi, %rbx     # Sets condition codes
    jge    copycontinue   # Loop if more elements to copy (Bwd taken)
    
copyend:
    rrmovq %rdx, %rax     # Return final destination pointer
    ret


#
# Array to sort
#
.pos 0x1000
array:
	.quad	0x41953		  # 268627
	.quad	0x6d6bc		  # 448188
	.quad	0xb69e1		  # 748001
	.quad	0xd8016		  # 884758
	.quad	0x9b7c0		  # 636864
	.quad	0xf42be		  # 1000126
	.quad	0x3752d		  # 226605
	.quad	0x42c87		  # 273543
	.quad	0xcacd1		  # 830673
	.quad	0x53978		  # 342392
	.quad	0x14e88		  # 85640
	.quad	0x79fa2		  # 499618
	.quad	0x834b1		  # 537777

#
# Temporary array.
#
temp:   .quad 0,13


#	
# Array size.
#	
size:   .quad 13
	
#
# Stack (32 sixty-four bit words is more than enough here).
#
.pos 0x3000
top:	            .quad 0x00000000,0x20     # top of stack.
bottom:             .quad 0x00000000          # bottom of stack.

